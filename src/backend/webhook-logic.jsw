// src/backend/webhook-logic.jsw
// Consolidated and corrected version

import { contacts } from 'wix-crm-backend';
import { register, sendSetPasswordEmail } from 'wix-members-backend';
import { elevate } from 'wix-auth';
import wixData from 'wix-data';

// Collection IDs
const MEMBERS_COLLECTION_ID = "Members/PrivateMembersData";
const STUDIO_APPLICATIONS_COLLECTION_ID = "Import1"; // Please verify this is your applications collection

/**
 * Finds an existing site member by email or contact ID, or creates a new one.
 * It prioritizes finding by email to prevent duplicate member accounts.
 * @param {string} contactId - The ID of the CRM contact.
 * @param {string} email - The email address of the member.
 * @returns {Promise<{memberId: string, memberData: object}>} An object containing the member's ID and data.
 */
export async function findOrCreateMember(contactId, email) {
    if (!contactId || !email) {
        throw new Error("Both contactId and email are required.");
    }

    try {
        // Define elevated functions for database operations using the correct pattern.
        const findMember = elevate(async (queryOptions) => {
            let query = wixData.query(MEMBERS_COLLECTION_ID);
            if (queryOptions.email) {
                query = query.eq("loginEmail", queryOptions.email);
            } else if (queryOptions.contactId) {
                query = query.eq("contactId", queryOptions.contactId);
            }
            const results = await query.limit(1).find();
            return results.items[0];
        });

        const updateMemberContact = elevate(async (memberId, newContactId) => {
            const toUpdate = {
                _id: memberId,
                contactId: newContactId
            };
            return wixData.update(MEMBERS_COLLECTION_ID, toUpdate);
        });

        // 1. First, try to find an existing member by email. This is the most reliable unique identifier for a member account.
        let member = await findMember({ email });
        if (member) {
            console.log(`Found existing member by email: ${member._id}`);
            // If the member was found by email but is missing the contactId, update it.
            if (!member.contactId) {
                await updateMemberContact(member._id, contactId);
                member.contactId = contactId; // Update in-memory object as well
                console.log(`Updated member ${member._id} with contactId ${contactId}`);
            }
            return { memberId: member._id, memberData: member };
        }

        // 2. If not found by email, try to find by contactId.
        member = await findMember({ contactId });
        if (member) {
            console.log(`Found existing member by contactId: ${member._id}`);
            return { memberId: member._id, memberData: member };
        }

        // 3. If no member is found, register a new one.
        console.log(`No existing member found. Creating new member for email: ${email}`);
        const registrationResult = await register(email, generateTempPassword(), {
            contactInfo: { contactId: contactId }
        });

        const newMember = registrationResult.member;
        console.log(`Created new member with ID: ${newMember._id}`);

        // Send password setup email but don't let it block the main flow.
        sendSetPasswordEmail(email).catch(emailError => {
            console.error(`Non-critical error: Failed to send password setup email to ${email}.`, emailError);
        });

        return { memberId: newMember._id, memberData: newMember };

    } catch (error) {
        console.error("Error in findOrCreateMember:", error);
        // Create a temporary ID if registration fails so the application data isn't lost.
        if (error.message.includes("is already a site member")) {
             console.error(`Registration failed because a member with email ${email} likely already exists but could not be found initially. Review data consistency.`);
        }
        const tempMemberId = `pending_${Date.now()}`;
        return { memberId: tempMemberId, memberData: null };
    }
}


/**
 * Transforms raw form data into a structured application record.
 */
export function buildApplicationData(payload, memberId) {
    const applicationData = {
        applicant: memberId,
        applicationID: payload.applicationID,
        email: payload.email,
        firstName: payload.firstName,
        lastName: payload.lastName,
        applicationStage: payload.applicationStage || "Applied",
        applicantStatus: payload.applicantStatus || "applicant",
        hasExperience: payload.hasExperience,
        experienceDescription: payload.experienceDescription,
        hasTechniques: payload.hasTechniques,
        practiceDescription: payload.practiceDescription,
        knowsSafety: payload.knowsSafety,
        safetyDescription: payload.safetyDescription,
        purchaseIntention: payload.purchaseIntention,
        selfID: payload.selfID,
        communityCommitment: payload.communityCommitment,
        communityInterest: payload.communityInterest,
        phone: payload.phone,
        address: payload.address,
        website: payload.website,
        instagram: payload.instagram,
        source: payload.source,
        questions: payload.questions,
        submissionDate: new Date(),
        status: "pending",
        formSource: "fillout_form",
        filloutURL: payload.filloutURL
    };

    // Clean undefined/null fields
    Object.keys(applicationData).forEach(key => {
        if (applicationData[key] === undefined || applicationData[key] === null) {
            delete applicationData[key];
        }
    });
    return applicationData;
}

/**
 * Creates a bidirectional link between member and application records.
 */
export async function updateMemberWithApplication(memberId, applicationId) {
    if (!memberId || !applicationId || memberId.startsWith('pending_')) {
        console.log('Skipping member update: memberId is missing or temporary.');
        return;
    }
    
    const elevatedGet = elevate(wixData.get);
    const elevatedUpdate = elevate(wixData.update);

    try {
        const fullMemberData = await elevatedGet(MEMBERS_COLLECTION_ID, memberId);
        
        const existingApplications = fullMemberData.studioApplications || [];
        
        if (!existingApplications.includes(applicationId)) {
            const updatedData = {
                ...fullMemberData,
                studioApplications: [...existingApplications, applicationId],
                lastApplicationDate: new Date()
            };
            await elevatedUpdate(MEMBERS_COLLECTION_ID, updatedData);
            console.log(`Updated member ${memberId} with application ${applicationId}`);
        } else {
            console.log(`Member ${memberId} already linked to application ${applicationId}.`);
        }
        
    } catch (error) {
        console.error(`Failed to update member ${memberId} with application:`, error);
    }
}

/**
 * Inserts the finalized application record into the database.
 */
export async function createApplicationRecord(applicationData) {
    if (!applicationData) {
        throw new Error("Application data cannot be empty.");
    }
    console.log("Inserting application record into database...");
    
    // This operation likely needs to be elevated as well.
    const newApplication = await elevate(wixData.insert)(STUDIO_APPLICATIONS_COLLECTION_ID, applicationData);
    
    console.log("New Studio Application record created with ID:", newApplication._id);
    return newApplication;
}

/**
 * Helper function to generate a secure temporary password.
 */
function generateTempPassword() {
    // Generates a more secure random password
    const buffer = new Uint8Array(12);
    crypto.getRandomValues(buffer);
    return btoa(String.fromCharCode.apply(null, buffer)).substring(0, 16);
}
